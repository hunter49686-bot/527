<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>527</title>
  <style>
    :root{
      --bg:#f6f4ef;
      --fg:#1f2328;
      --muted:#6b7280;
      --tile:#ffffff;
      --tileBorder:#e5e7eb;
      --accent:#2f6f6d;
      --good:#1f7a36;
      --bad:#b42318;
      --shadow: 0 6px 18px rgba(0,0,0,.06);
      --radius: 16px;
      --tileSize: 54px;
      --tileGap: 10px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family:var(--font);
      background:var(--bg);
      color:var(--fg);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    main{
      max-width: 520px;
      margin: 0 auto;
      padding: 18px 16px 28px;
      min-height: 100dvh;
      display:flex;
      flex-direction:column;
      gap: 16px;
    }
    header{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      padding: 6px 2px 0;
    }
    .brand{
      font-weight:700;
      letter-spacing:.02em;
      font-size: 22px;
    }
    .puzzle-id{
      color:var(--muted);
      font-size: 14px;
      letter-spacing:.06em;
    }
    .card{
      background:rgba(255,255,255,.55);
      border:1px solid rgba(229,231,235,.9);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 16px;
    }
    .subtle{
      color:var(--muted);
      font-size: 13px;
      line-height: 1.4;
    }

    .toprow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
      margin-bottom:10px;
    }
    .loader{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:center;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 12px;
      border-radius:999px;
      border:1px solid rgba(31,35,40,.14);
      background: rgba(255,255,255,.6);
      box-shadow: 0 2px 10px rgba(0,0,0,.03);
      font-size: 12px;
      color: var(--muted);
      white-space:nowrap;
    }
    .pill b{ color: var(--fg); font-weight:800; }

    .rack, .tray{
      display:flex;
      flex-wrap:wrap;
      gap: var(--tileGap);
      align-items:center;
      justify-content:center;
      padding: 6px 2px;
    }

    .tile{
      width: var(--tileSize);
      height: var(--tileSize);
      border-radius: 14px;
      background: var(--tile);
      border: 1px solid var(--tileBorder);
      box-shadow: 0 2px 10px rgba(0,0,0,.05);
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      user-select:none;
      touch-action: manipulation;
      transition: transform 120ms ease, border-color 120ms ease;
      cursor:pointer;
    }
    .tile:active{ transform: scale(.98); }
    .tile[aria-disabled="true"]{
      opacity:.35;
      cursor:not-allowed;
      box-shadow:none;
    }
    .letter{
      font-size: 20px;
      font-weight: 700;
    }
    .value{
      position:absolute;
      right: 9px;
      bottom: 8px;
      font-size: 11px;
      color: var(--muted);
      font-weight: 600;
    }

    .tray-wrap{
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:stretch;
    }
    .tray-title{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 0 2px;
    }
    .word{
      font-weight:700;
      letter-spacing:.08em;
    }
    .status{
      font-size: 13px;
      color: var(--muted);
    }
    .status.good{ color: var(--good); }
    .status.bad{ color: var(--bad); }

    .actions{
      display:flex;
      gap: 10px;
      justify-content:center;
      flex-wrap:wrap;
      padding-top: 2px;
    }
    button{
      border:none;
      border-radius: 999px;
      padding: 12px 16px;
      font-weight: 700;
      font-size: 14px;
      cursor:pointer;
      transition: transform 120ms ease, opacity 120ms ease, background 120ms ease;
      background: var(--fg);
      color: white;
      min-width: 140px;
    }
    button.secondary{
      background: transparent;
      color: var(--fg);
      border: 1px solid rgba(31,35,40,.18);
      box-shadow: 0 2px 10px rgba(0,0,0,.03);
      min-width:auto;
      padding: 10px 12px;
      font-size: 13px;
    }
    button:active{ transform: scale(.99); }
    button:disabled{
      opacity:.45;
      cursor:not-allowed;
    }

    input[type="file"]{ display:none; }

    .result{
      display:none;
      text-align:center;
      padding-top: 4px;
    }
    .result .big{
      font-size: 22px;
      font-weight: 800;
      letter-spacing:.08em;
    }
    .result .score{
      margin-top: 6px;
      font-size: 16px;
      font-weight: 800;
    }
    .result .meta{
      margin-top: 4px;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.5;
      white-space:pre-line;
    }
    .divider{
      height:1px;
      background: rgba(31,35,40,.08);
      margin: 14px 0;
    }

    footer{
      margin-top:auto;
      padding: 6px 2px 0;
      text-align:center;
      color: var(--muted);
      font-size: 12px;
    }
  </style>
</head>

<body>
<main>
  <header>
    <div class="brand">527</div>
    <div class="puzzle-id" id="puzzleId">Â· #â€”</div>
  </header>

  <section class="card">
    <div class="toprow">
      <div class="subtle">
        Each day, 527 picks a word (5â€“7 letters) and scrambles its letters into todayâ€™s tiles. Build the highest-scoring word. One submission.
      </div>

      <div class="loader">
        <span class="pill" id="dictPill">Dictionary: <b>loadingâ€¦</b></span>
        <button class="secondary" id="reloadBtn" type="button">Reload words.txt</button>
        <label class="pill" for="dictFile" style="cursor:pointer;">
          <b>Pick .txt</b>
        </label>
        <input id="dictFile" type="file" accept=".txt,text/plain" />
      </div>
    </div>

    <div class="rack" id="rack"></div>

    <div class="divider"></div>

    <div class="tray-wrap">
      <div class="tray-title">
        <div class="word" id="wordDisplay">_ _ _ _ _</div>
        <div class="status" id="status">Loadingâ€¦</div>
      </div>

      <div class="tray" id="tray" aria-label="Tray (drag to reorder)"></div>

      <div class="actions">
        <button class="secondary" id="clearBtn" type="button">Clear</button>
        <button id="submitBtn" type="button" disabled>Submit</button>
      </div>

      <div class="result" id="result">
        <div class="divider"></div>
        <div class="big" id="resultWord">â€”</div>
        <div class="score" id="resultScore">Score â€”</div>
        <div class="meta" id="resultMeta">â€”</div>
        <div class="actions" style="margin-top:12px;">
          <button class="secondary" id="shareBtn" type="button">Copy Share</button>
        </div>
      </div>
    </div>
  </section>

  <footer>
    Tip: for testing different days without changing your clock, add <b>?seed=demo1</b> (or any value) to the URL.
  </footer>
</main>

<script>
/**
 * 527 â€” daily word -> scrambled rack
 *
 * Files:
 * - index.html
 * - words.txt (newline-separated; preferably Aâ€“Z only; ideally 5â€“7 letter everyday words)
 *
 * Behavior:
 * - Deterministic daily pick: chooses a word from eligible 5â€“7 letter dictionary words
 * - Rack: scrambled letters of that word
 * - Player: submits any valid 5â€“7 letter word constructible from rack letters
 * - Best possible score: computed by enumerating all valid words possible from rack (multiset-safe)
 * - "Top X%": percentile among all valid words possible from rack (not players)
 */

/* ---------------------- VALUES ---------------------- */

const LETTER_VALUE = (() => {
  const map = {};
  const set = (letters, v) => letters.split("").forEach(ch => map[ch] = v);
  set("AEIOULNSTR", 1);
  set("DG", 2);
  set("BCMP", 3);
  set("FHVWY", 4);
  set("K", 5);
  set("JX", 7);
  set("QZ", 8);
  return map;
})();

const LENGTH_MULT = { 5: 1.00, 6: 1.15, 7: 1.30 };

/* ---------------------- DOM ---------------------- */

const elRack = document.getElementById("rack");
const elTray = document.getElementById("tray");
const elStatus = document.getElementById("status");
const elWordDisplay = document.getElementById("wordDisplay");
const elSubmit = document.getElementById("submitBtn");
const elClear = document.getElementById("clearBtn");
const elResult = document.getElementById("result");
const elResultWord = document.getElementById("resultWord");
const elResultScore = document.getElementById("resultScore");
const elResultMeta = document.getElementById("resultMeta");
const elShare = document.getElementById("shareBtn");
const elDictPill = document.getElementById("dictPill");
const elDictFile = document.getElementById("dictFile");
const elReloadBtn = document.getElementById("reloadBtn");

/* ---------------------- STATE ---------------------- */

const state = {
  submitted: false,
  rack: [],
  tray: [],
  dict: new Set(),
  dictLoaded: false,

  dailyWord: null,
  eligibleWords: [],

  bestPossibleScore: null,
  bestPossibleWords: [],
  validWordScores: []
};

/* ---------------------- UTIL / SEED ---------------------- */

function mulberry32(seed){
  return function(){
    seed |= 0; seed = seed + 0x6D2B79F5 | 0;
    let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

function hashString(str){
  let h = 2166136261;
  for(let i=0;i<str.length;i++){
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}

function todayKey(){
  // Optional test override: /?seed=anything
  const params = new URLSearchParams(window.location.search);
  const s = params.get("seed");
  if (s && s.trim().length) return s.trim();

  const d = new Date();
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth()+1).padStart(2,"0");
  const dd = String(d.getDate()).padStart(2,"0");
  return `${yyyy}-${mm}-${dd}`;
}

function puzzleNumber(){
  const start = new Date("2026-01-01T00:00:00");
  const now = new Date();
  const days = Math.floor((now - start) / (24*60*60*1000));
  return Math.max(1, days + 1);
}

function shuffleArray(arr, rnd){
  for(let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(rnd() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

/* ---------------------- DICTIONARY ---------------------- */

function normalizeWord(w){
  return w.trim().toUpperCase().replace(/[^A-Z]/g,"");
}

function loadWordsFromText(text){
  const set = new Set();
  const lines = text.split(/\r?\n/);
  for(const line of lines){
    const w = normalizeWord(line);
    if(w.length >= 2) set.add(w);
  }
  return set;
}

function updateDictPill(){
  if(!state.dictLoaded){
    elDictPill.innerHTML = `Dictionary: <b>not loaded</b>`;
    return;
  }
  elDictPill.innerHTML = `Dictionary: <b>${state.dict.size.toLocaleString()}</b>`;
}

async function tryFetchWordsTxt(){
  try{
    const res = await fetch("./words.txt", { cache: "no-store" });
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const text = await res.text();
    const set = loadWordsFromText(text);
    return set;
  }catch{
    return null;
  }
}

function buildEligibleWordList(){
  // Eligible: 5â€“7 letter Aâ€“Z words
  const words = [];
  for (const w of state.dict){
    if (/^[A-Z]{5,7}$/.test(w)) words.push(w);
  }
  words.sort(); // stable order
  state.eligibleWords = words;
}

function pickDailyWord(){
  if (!state.eligibleWords || state.eligibleWords.length === 0) return null;
  const seed = hashString(todayKey());
  const idx = seed % state.eligibleWords.length;
  return state.eligibleWords[idx];
}

function rackFromDailyWord(word){
  const seed = hashString(todayKey()) + 1337; // separate from word-choice seed
  const rnd = mulberry32(seed);

  const letters = word.split("");     // 5â€“7 letters
  shuffleArray(letters, rnd);

  return letters.map((ch, idx) => ({
    id: `${idx}-${ch}-${seed}`,
    letter: ch,
    value: LETTER_VALUE[ch] ?? 1,
    used: false
  }));
}

async function applyDailyWordAndRack(){
  buildEligibleWordList();
  state.dailyWord = pickDailyWord();

  // Reset play state
  state.submitted = false;
  state.tray = [];

  if (!state.dailyWord){
    state.rack = [];
    state.bestPossibleScore = null;
    state.bestPossibleWords = [];
    state.validWordScores = [];
    elStatus.textContent = "No eligible 5â€“7 letter words in dictionary";
    elStatus.className = "status bad";
    render();
    return;
  }

  state.rack = rackFromDailyWord(state.dailyWord);

  // Recompute best possible for today's rack
  await recomputeDailyBest();

  render();
}

/* ---------------------- SCORING ---------------------- */

function isWordValid(w){
  return state.dict.has(w);
}

function lengthMultiplier(len){
  return LENGTH_MULT[len] ?? 0;
}

function letterSumFromWord(word){
  let sum = 0;
  for(const ch of word){
    sum += (LETTER_VALUE[ch] ?? 1);
  }
  return sum;
}

function computeScore(word){
  const len = word.length;
  const base = letterSumFromWord(word);
  const mult = lengthMultiplier(len);
  return Math.round(base * mult);
}

/* ---------------------- BEST-POSSIBLE SOLVER ---------------------- */

function rackCounts(){
  const counts = new Map();
  for(const t of state.rack){
    counts.set(t.letter, (counts.get(t.letter) ?? 0) + 1);
  }
  return counts;
}

async function recomputeDailyBest(){
  state.bestPossibleScore = null;
  state.bestPossibleWords = [];
  state.validWordScores = [];

  if (!state.rack || state.rack.length < 5) return;

  const counts = rackCounts();
  const letters = Array.from(counts.keys()).sort(); // deterministic
  const minLen = 5;
  const maxLen = Math.min(7, state.rack.length);

  function dfs(prefix, remaining, targetLen){
    if(prefix.length === targetLen){
      if(isWordValid(prefix)){
        const score = computeScore(prefix);
        state.validWordScores.push(score);
        if(state.bestPossibleScore === null || score > state.bestPossibleScore){
          state.bestPossibleScore = score;
          state.bestPossibleWords = [prefix];
        }else if(score === state.bestPossibleScore){
          if(state.bestPossibleWords.length < 10) state.bestPossibleWords.push(prefix);
        }
      }
      return;
    }
    for(const ch of letters){
      const c = remaining.get(ch) ?? 0;
      if(c <= 0) continue;
      remaining.set(ch, c - 1);
      dfs(prefix + ch, remaining, targetLen);
      remaining.set(ch, c);
    }
  }

  for(let len=minLen; len<=maxLen; len++){
    dfs("", counts, len);
  }

  state.validWordScores.sort((a,b)=>a-b);
}

function percentileAmongPossible(score){
  const scores = state.validWordScores;
  if(!scores || scores.length === 0) return null;

  // Top X% where higher is better:
  // count how many scores are strictly greater than yours
  let lo = 0, hi = scores.length;
  while(lo < hi){
    const mid = (lo + hi) >> 1;
    if(scores[mid] <= score) lo = mid + 1;
    else hi = mid;
  }
  const greater = scores.length - lo;
  return (greater / scores.length) * 100;
}

function shareEmojiLine(len, score){
  if(!state.bestPossibleScore || state.bestPossibleScore <= 0) return "ðŸŸ©".repeat(len);
  const ratio = score / state.bestPossibleScore;
  const emoji =
    ratio >= 0.95 ? "ðŸŸ©" :
    ratio >= 0.85 ? "ðŸŸ¨" :
    ratio >= 0.70 ? "ðŸŸ§" : "ðŸŸ¥";
  return emoji.repeat(len);
}

/* ---------------------- GAMEPLAY UI ---------------------- */

function trayWord(){
  return state.tray.map(id => state.rack.find(t => t.id === id)?.letter ?? "").join("");
}

function validate(){
  if(state.submitted) return;

  if(!state.dictLoaded){
    elStatus.textContent = "Loading dictionaryâ€¦";
    elStatus.className = "status";
    elSubmit.disabled = true;
    elWordDisplay.textContent = "_ _ _ _ _";
    return;
  }
  if(!state.rack || state.rack.length === 0){
    elStatus.textContent = "No rack available";
    elStatus.className = "status bad";
    elSubmit.disabled = true;
    elWordDisplay.textContent = "_ _ _ _ _";
    return;
  }

  const w = trayWord();
  const len = w.length;

  elWordDisplay.textContent = (len === 0) ? "_ _ _ _ _" : w.split("").join(" ");

  if(len < 5){
    elStatus.textContent = "5â€“7 letters";
    elStatus.className = "status";
    elSubmit.disabled = true;
    return;
  }
  if(len > 7){
    elStatus.textContent = "Max 7 letters";
    elStatus.className = "status bad";
    elSubmit.disabled = true;
    return;
  }
  if(!/^[A-Z]+$/.test(w)){
    elStatus.textContent = "Letters only";
    elStatus.className = "status bad";
    elSubmit.disabled = true;
    return;
  }

  if(isWordValid(w)){
    elStatus.textContent = "Valid";
    elStatus.className = "status good";
    elSubmit.disabled = false;
  } else {
    elStatus.textContent = "Not in word list";
    elStatus.className = "status bad";
    elSubmit.disabled = true;
  }
}

function render(){
  // rack
  elRack.innerHTML = "";
  (state.rack || []).forEach(tile => {
    const btn = document.createElement("div");
    btn.className = "tile";
    btn.setAttribute("role","button");
    btn.setAttribute("tabindex","0");
    btn.setAttribute("aria-disabled", state.submitted || tile.used ? "true" : "false");
    btn.innerHTML = `<div class="letter">${tile.letter}</div><div class="value">${tile.value}</div>`;

    const onPick = () => {
      if(state.submitted || tile.used) return;
      tile.used = true;
      state.tray.push(tile.id);
      render();
    };

    btn.addEventListener("click", onPick);
    btn.addEventListener("keydown", (e)=>{ if(e.key==="Enter"||e.key===" ") onPick(); });

    elRack.appendChild(btn);
  });

  // tray
  elTray.innerHTML = "";
  state.tray.forEach((id, idx) => {
    const tile = state.rack.find(t => t.id === id);
    if(!tile) return;

    const chip = document.createElement("div");
    chip.className = "tile";
    chip.draggable = !state.submitted;
    chip.dataset.id = id;
    chip.innerHTML = `<div class="letter">${tile.letter}</div><div class="value">${tile.value}</div>`;

    chip.addEventListener("click", () => {
      if(state.submitted) return;
      state.tray.splice(idx, 1);
      tile.used = false;
      render();
    });

    chip.addEventListener("dragstart", (e) => {
      e.dataTransfer.setData("text/plain", id);
      e.dataTransfer.effectAllowed = "move";
    });

    chip.addEventListener("dragover", (e) => {
      if(state.submitted) return;
      e.preventDefault();
      e.dataTransfer.dropEffect = "move";
    });

    chip.addEventListener("drop", (e) => {
      if(state.submitted) return;
      e.preventDefault();
      const fromId = e.dataTransfer.getData("text/plain");
      const toId = id;
      if(!fromId || fromId === toId) return;

      const fromIdx = state.tray.indexOf(fromId);
      const toIdx = state.tray.indexOf(toId);
      if(fromIdx < 0 || toIdx < 0) return;

      state.tray.splice(fromIdx, 1);
      state.tray.splice(toIdx, 0, fromId);
      render();
    });

    elTray.appendChild(chip);
  });

  elClear.disabled = state.submitted || state.tray.length === 0;
  elResult.style.display = state.submitted ? "block" : "none";

  validate();
}

/* ---------------------- LOAD DICT + INIT ---------------------- */

async function loadDictionaryAuto(){
  state.dictLoaded = false;
  state.dict = new Set();
  updateDictPill();
  render();

  const fetched = await tryFetchWordsTxt();
  if(fetched && fetched.size){
    state.dict = fetched;
    state.dictLoaded = true;
    updateDictPill();
    await applyDailyWordAndRack();
    return;
  }

  // Minimal fallback if words.txt missing
  state.dict = new Set([
    "LIMIT","TRILL","TIMID","TRIM","LIMIT","MIRTH","LITER","MIRTL","MILT","LIMIR"
  ]);
  state.dictLoaded = true;
  updateDictPill();
  await applyDailyWordAndRack();
}

elDictFile.addEventListener("change", async (e) => {
  const file = e.target.files?.[0];
  if(!file) return;
  const text = await file.text();
  state.dict = loadWordsFromText(text);
  state.dictLoaded = true;
  updateDictPill();
  await applyDailyWordAndRack();
});

elReloadBtn.addEventListener("click", async () => {
  await loadDictionaryAuto();
});

function init(){
  document.getElementById("puzzleId").textContent =
    `Â· #${String(puzzleNumber()).padStart(3,"0")}`;

  state.rack = [];
  state.tray = [];
  state.submitted = false;

  render();
  loadDictionaryAuto();
}

/* ---------------------- BUTTONS ---------------------- */

elClear.addEventListener("click", () => {
  if(state.submitted) return;
  state.rack.forEach(t => t.used = false);
  state.tray = [];
  render();
});

elSubmit.addEventListener("click", () => {
  if(state.submitted) return;

  const w = trayWord();
  if(!(w.length >= 5 && w.length <= 7 && isWordValid(w))) return;

  state.submitted = true;

  const score = computeScore(w);
  const best = state.bestPossibleScore;
  const topPct = percentileAmongPossible(score);

  const topLine = (topPct === null)
    ? "Top â€”% (possible words)"
    : `Top ${topPct.toFixed(1)}% (possible words)`;

  const bestLine = (best === null)
    ? "Best possible score today: â€”"
    : `Best possible score today: ${best}`;

  elResultWord.textContent = w;
  elResultScore.textContent = `Score ${score}`;
  elResultMeta.textContent = `${topLine}\n${bestLine}`;

  render();
});

elShare.addEventListener("click", async () => {
  const w = trayWord();
  const score = computeScore(w);
  const num = String(puzzleNumber()).padStart(3,"0");
  const line = shareEmojiLine(w.length, score);

  const best = state.bestPossibleScore;
  const topPct = percentileAmongPossible(score);

  const topLine = (topPct === null) ? "Top â€”% (possible words)" : `Top ${topPct.toFixed(1)}% (possible words)`;
  const bestLine = (best === null) ? "Best: â€”" : `Best: ${best}`;

  const text =
`527 #${num}
${line}
Score: ${score}
${topLine}
${bestLine}`;

  try{
    await navigator.clipboard.writeText(text);
    elShare.textContent = "Copied";
    setTimeout(()=> elShare.textContent = "Copy Share", 1200);
  }catch{
    window.prompt("Copy this:", text);
  }
});

// Prevent dropping outside tray from navigating
window.addEventListener("dragover", e => e.preventDefault());
window.addEventListener("drop", e => e.preventDefault());

init();
</script>
</body>
</html>
